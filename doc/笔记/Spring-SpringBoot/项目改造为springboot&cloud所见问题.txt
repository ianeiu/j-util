项目改造为springboot&cloud所见问题
1----------------------------------------------------------------------------------------------------
现象：引入layer.js出现undefinedcss目录.txt
原因：layer.js与layui.js冲突
解决：将layui.js 第二个.link 中的n.dir改为(n.dir?n.dir:r)
2----------------------------------------------------------------------------------------------------
现象：配置CommonsMultipartResolver，上传文件返回异常HttpMediaTypeNotSupportedException
原因：同下
解决：FUN1、不配置CommonsMultipartResolver
	FUN2、启动类@EnableAutoConfiguration(exclude = {MultipartAutoConfiguration.class}) （不建议）
3----------------------------------------------------------------------------------------------------
现象：上传文件返回异常java.lang.ClassCastException: org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile cannot be cast to org.springframework.web.multipart.commons.CommonsMultipartFile
原因：FileUtil中multipartToFile的代码片段  CommonsMultipartFile cf = (CommonsMultipartFile)multfile
	与springboot自带的org.springframework.web.multipart.MultipartFile冲突
	import org.springframework.web.multipart.commons.CommonsMultipartResolver;//这是旧项目引入的
	import org.springframework.web.multipart.MultipartFile;//这是springboot整合的
解决：采用输入流方式获取File对象，具体代码自行百度
4----------------------------------------------------------------------------------------------------
现象：Shiro 自定义 filter 匹配异常，无限拦截重定向
参考：http://www.hillfly.com/2017/179.html
原因：自定义Filter注册为了 Bean交给 Spring托管,它会被自动注册到 FilterChain中。请求先经过自定义Filter，导致请求被其先消费掉了，而ShiroFilter成了摆设。
解决：FUN1、利用 FilterRegistrationBean 注册自定义 Filter （建议使用）
		ex：
			@Bean
			public CasFilter casFilter(){
				CasFilter cf = new CasFilter();
				cf.setSuccessUrl(successUrl);
				cf.setFailureUrl(failureUrl);
				return cf;
			}
			
			/**
			 * 注册casFilter
			 * @param casFilter
			 * @return
			 */
			@Bean
			public FilterRegistrationBean registCasFilter(CasFilter casFilter) {
				FilterRegistrationBean cas = new FilterRegistrationBean();
				cas.setFilter(casFilter);
				cas.setEnabled(false);	//该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理  x
				return cas;
			}
			
			/**
			 * 注册shiroFilter
			 * @param securityManager
			 * @param casFilter
			 * @param logoutFilter
			 * @return
			 */
			@Bean
			public ShiroFilterFactoryBean shiroFilter(DefaultWebSecurityManager securityManager,
					CasFilter casFilter,LogoutFilter logoutFilter) {
				ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
				...
				Map<String,Filter> filters = new HashMap<>();
				filters.put("casFilter",casFilter);
				filters.put("logoutFilter", logoutFilter);
				shiroFilterFactoryBean.setFilters(filters);		//添加casFilter到shiroFilter
				...
			}
	FUN2、将 CasFilter注册为了 Bean交给 Spring托管,它会被自动注册到 FilterChain中，那我们如果不把它注册为 Bean就可以避免这个问题了。
		ex:
			/**
			 * 注册shiroFilter
			 * @param securityManager
			 * @return
			 */
			@Bean
			public ShiroFilterFactoryBean shiroFilter(DefaultWebSecurityManager securityManager) {
				ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
				...
				Map<String,Filter> filters = new HashMap<>();
				filters.put("casFilter",new CasFilter());
				filters.put("logoutFilter", new LogoutFilter());
				shiroFilterFactoryBean.setFilters(filters);		//添加casFilter到shiroFilter
				...
			}
5----------------------------------------------------------------------------------------------------
现象：启动报错Caused by: java.lang.NoClassDefFoundError: ch/qos/logback/classic/turbo/TurboFilter
原因:springboot1.3.x和1.3.x以下版本才支持log4j的日志配置，1.3.x以上版本只支持log4j2和logback的日志配置
解决：使用log4j2或logback
6----------------------------------------------------------------------------------------------------
现象：项目mvn install后jar包，启动报错，未获取到某个包下的class对象集合
原因：springboot项目打包后获取包资源所在路径与启动main不一样
	ex：//jarPaht:file:/E:/IDEABuilder/fs/tyrz-springboot/tyrz-front/target/fsrzfw.jar!/BOOT-INF/classes!/cn/com/do1/component/identitySource/service/impl
解决：逐一分割路径获取类对象
	/**
	 * 获得包下面的所有的class
	 * @author FengHuayuan
	 * @date 2018年4月21日 下午12:25:20.
	 * @param pack
	 * @return
	 */
	public static List<Class<?>> getClassesFromPackage(String pack) {
		List<Class<?>> clazzs = new ArrayList<Class<?>>();
		// 是否循环搜索子包
		boolean recursive = true;
		// 包名字
		String packageName = pack;
		// 包名对应的路径名称
		String packageDirName = packageName.replace('.', '/');
		Enumeration<URL> dirs;
		try {
			dirs = Thread.currentThread().getContextClassLoader().getResources(packageDirName);
			while (dirs.hasMoreElements()) {
				URL url = dirs.nextElement();
				String protocol = url.getProtocol();
				if ("file".equals(protocol)) {
					log.debug("*****【File类型】的扫描！");
					String filePath = URLDecoder.decode(url.getFile(), "UTF-8");
					findClassInPackageByFile(packageName, filePath, recursive, clazzs);
				} else if ("jar".equals(protocol)) {
					log.debug("*****【Jar类型】的扫描！");
					String filePath = URLDecoder.decode(url.getFile(), "UTF-8");
					getClasssFromJarFile(filePath, clazzs);//wm add
				}
			}

		} catch (Exception e) {
			log.error(e.getMessage(),e);
		}
		return clazzs;
	}
	
	/** 
	 * 从jar文件中读取指定目录下面的所有的class文件 
	 * springboot打jar包专用
	 * @author wm
	 * @param jarPaht   jar文件存放的位置 
	 * @param filePaht    指定的文件目录 
	 * @param clazzs 所有的的class的对象 
	 */  
	public static void getClasssFromJarFile(String jarPath,List<Class<?>> clazzs) {  

		log.info("getClasssFromJarFile - jarPath:"+jarPath);//wm
		//jarPaht:file:/E:/IDEABuilder/fs/tyrz-springboot/tyrz-front/target/fsrzfw.jar!/BOOT-INF/classes!/cn/com/do1/component/identitySource/service/impl
		String[] jarPaths = jarPath.split("!");
		String jarPaht=jarPaths[0].substring(6);//去掉file:/
		String startDir = (jarPaths[1]+jarPaths[2]).substring(1);//去掉/
		
	    JarFile jarFile = null;  
	    try {  
	        jarFile = new JarFile(jarPaht);  
	    } catch (IOException e1) {  
	        e1.printStackTrace();  
	    }  
	  
	    List<JarEntry> jarEntryList = new ArrayList<JarEntry>();  
	  
	    Enumeration<JarEntry> ee = jarFile.entries();  
	    while (ee.hasMoreElements()) {  
	        JarEntry entry = (JarEntry) ee.nextElement();  
	        if (entry.getName().startsWith(startDir) && entry.getName().endsWith(".class")) {  
		        log.info("getClasssFromJarFile - entry:"+entry.getName());//wm
	            jarEntryList.add(entry);  
	        }  
	    }  
	    for (JarEntry entry : jarEntryList) {  
	        String className = entry.getName().replace('/', '.');  
			//   BOOT-INF/classes/cn/com/do1/component/identitySource/service/impl/XXX.class
	        className = className.substring(17, className.length() - 6);//去掉  BOOT-INF/classes/     .class
	        try {  
	            clazzs.add(Thread.currentThread().getContextClassLoader().loadClass(className));  
	        } catch (ClassNotFoundException e) {  
	            e.printStackTrace();  
	        }  
	    }  
	  
	}

7----------------------------------------------------------------------------------------------------
现象：启动jar包，访问登录，报NoClassDefFoundError RedisCacheManager		
解决：注释pom配置
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<optional>true</optional>
		</dependency>
8----------------------------------------------------------------------------------------------------
现象：jar包启动无法访问jsp的问题
原因:https://www.jb51.net/article/141474.htm
解决：亲测，需两步
	步骤1、新增两个类
		import java.io.File;
		import java.net.MalformedURLException;
		import java.net.URL;
		
		import org.apache.catalina.Context;
		import org.apache.catalina.Lifecycle;
		import org.apache.catalina.LifecycleEvent;
		import org.apache.catalina.LifecycleListener;
		import org.apache.catalina.WebResourceRoot.ResourceSetType;
		import org.springframework.util.ResourceUtils;
		
		/**
		 * Add main class fat jar/exploded directory into tomcat ResourceSet.
		 *
		 * @author hengyunabc 2017-07-29
		 *
		 */
		public class StaticResourceConfigurer implements LifecycleListener {
		
			private final Context context;
		
			StaticResourceConfigurer(Context context) {
				this.context = context;
			}
		
			@Override
			public void lifecycleEvent(LifecycleEvent event) {
				if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
					URL location = this.getClass().getProtectionDomain().getCodeSource().getLocation();
		
					if (ResourceUtils.isFileURL(location)) {
						// when run as exploded directory
						String rootFile = location.getFile();
						if (rootFile.endsWith("/BOOT-INF/classes/")) {
							rootFile = rootFile.substring(0, rootFile.length() - "/BOOT-INF/classes/".length() + 1);
						}
						if (!new File(rootFile, "META-INF" + File.separator + "resources").isDirectory()) {
							return;
						}
		
						try {
							location = new File(rootFile).toURI().toURL();
						} catch (MalformedURLException e) {
							throw new IllegalStateException("Can not add tomcat resources", e);
						}
					}
		
					String locationStr = location.toString();
					if (locationStr.endsWith("/BOOT-INF/classes!/")) {
						// when run as fat jar
						locationStr = locationStr.substring(0, locationStr.length() - "/BOOT-INF/classes!/".length() + 1);
						try {
							location = new URL(locationStr);
						} catch (MalformedURLException e) {
							throw new IllegalStateException("Can not add tomcat resources", e);
						}
					}
					this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, "/", location,
							"/META-INF/resources");
		
				}
			}
		}
		
		import org.apache.catalina.Context;
		import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
		import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;
		import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;
		import org.springframework.boot.context.embedded.tomcat.TomcatContextCustomizer;
		import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;
		import org.springframework.context.annotation.Bean;
		import org.springframework.context.annotation.Configuration;
		
		/**
		 * 处理1.5版本jar包启动无法访问jsp的问题
		 * <p>Title: TomcatConfig</p>  
		 * <p>Description: </p>  
		 * @author wm  
		 * @date 2018年7月24日
		 */
		@Configuration
		@ConditionalOnProperty(name = "tomcat.staticResourceCustomizer.enabled", matchIfMissing = true)
		public class TomcatConfig {
			@Bean
			public EmbeddedServletContainerCustomizer staticResourceCustomizer() {
				return new EmbeddedServletContainerCustomizer() {
					@Override
					public void customize(ConfigurableEmbeddedServletContainer container) {
						if (container instanceof TomcatEmbeddedServletContainerFactory) {
							((TomcatEmbeddedServletContainerFactory) container)
									.addContextCustomizers(new TomcatContextCustomizer() {
										@Override
										public void customize(Context context) {
											context.addLifecycleListener(new StaticResourceConfigurer(context));
										}
									});
						}
					}
		
				};
			}
		}
		
	步骤2，pom配置
		<resources>
			...
			<resource>
                <directory>src/main/webapp</directory>
                <!-- 处理jar包启动无法访问jsp的问题 -->
                <targetPath>META-INF/resources</targetPath>
                <filtering>true</filtering>
                <includes>
                    <include>**/**</include>
                </includes>
            </resource> 
		</resources>

9----------------------------------------------------------------------------------------------------
现象：启动项目报错ClassNotFoundException: javax.ws.rs.core.Response$StatusType
解决：pom引入jsr311-api（g:javax.ws.rs）(a:jsr311-api)（v:1.1.1）
10----------------------------------------------------------------------------------------------------
现象：整合redis报 NOAUTH Authentication required
原因：spring.redis.password=yourpassword 配置在JedisConnectionFactory中没有被加载进去
解决：手动获取自定义或原配置密码进行配置
	@Value("${redis.address}")
    private String hostName;
    @Value("${redis.port}")
    private String port;
    @Value("${redis.password}")
    private String password;
    
    @Bean
    public JedisConnectionFactory jedisConnectionFactory(){
    	JedisConnectionFactory jcf = new JedisConnectionFactory();
    	jcf.setHostName(hostName);
    	jcf.setPort(Integer.parseInt(port));
    	jcf.setPassword(password);
    	return jcf;
    }
11----------------------------------------------------------------------------------------------------
现象：整合swagger组件，HTTP接口统一处理异常失效
原因：GlobalExceptionResolver implements HandlerExceptionResolver
	private boolean isReturnReponseBody(Object handler) {
		if(((HandlerMethod) handler).hasMethodAnnotation(ResponseBody.class)) {
			return true;
		}
		HandlerMethod hm = (HandlerMethod) handler;
		if(hm.getBean().getClass().isAnnotationPresent(RestController.class)) {
			return true;
		}
		/*Method method = hm.getMethod();
		Class<?> returnType = method.getReturnType();
		if(returnType.isAnnotationPresent(ResponseBody.class)) {
			return true;
		}*/	
		return false;
	}
	result ： false
解决：新增判断
	if(((HandlerMethod) handler).hasMethodAnnotation(ApiOperation.class)) {
		return true;
	}
12----------------------------------------------------------------------------------------------------
		