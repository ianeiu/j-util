package com.wm.demo.javabase.d1tod4;

import org.junit.Test;

public class Demo01Basse {
	
	@Test
	public void testOper01Out() {
		byte b1 = 127;
		byte b2 = (byte)128;//-128	
		byte b3 = (byte)129;//-127
		byte b4 = (byte)130;//-126
		
		System.out.println(b1);
		System.out.println(b2);
		System.out.println(b3);
		System.out.println(b4);
	}
	
	@Test
	public void testOperator() {
		int i = 2<<3;//16   2*2*2*2
		int i2 = 8<<1;//16	8*2	
		int i3 = 8>>1;//4	8/2
		
		System.out.println(i);
		System.out.println(i2);
		System.out.println(i3);
	}
	
	/*
		分析：因为是位运算，所以我们必须先把数据换算成二进制。
		
		3的二进制：11
			00000000 00000000 00000000 00000011
		4的二进制：100
			00000000 00000000 00000000 00000100
		
		&位与运算：有0则0。
			00000000 00000000 00000000 00000011
		   &00000000 00000000 00000000 00000100
			-----------------------------------
			00000000 00000000 00000000 00000000
			结果是：0
			
		|位或运算：有1则1。
			00000000 00000000 00000000 00000011
		   |00000000 00000000 00000000 00000100
			-----------------------------------
			00000000 00000000 00000000 00000111
			结果是：7
			
		^位异或运算：相同则0，不同则1。
			00000000 00000000 00000000 00000011
		   &00000000 00000000 00000000 00000100
			-----------------------------------
			00000000 00000000 00000000 00000111
			结果是：7
			
		~按位取反运算符：0变1，1变0
			00000000 00000000 00000000 00000011
		   ~11111111 11111111 11111111 11111100 (补码)
		   
		   补码：11111111 11111111 11111111 11111100
		   反码：11111111 11111111 11111111 11111011
		   原码：10000000 00000000 00000000 00000100
			结果是：-4
	*/
	@Test
	public void testOperator2() {
		//&,|,^,~
		
		System.out.println(3 & 4);
		System.out.println(3 | 4);
		System.out.println(3 ^ 4);
		System.out.println(~3);
	}
	
	/*
		<<:左移	左边最高位丢弃，右边补齐0
		>>:右移	最高位是0，左边补齐0；最高为是1，左边补齐1
		>>>:无符号右移 无论最高位是0还是1，左边补齐0
		
		面试题：
			请用最有效率的方式写出计算2乘以8的结果?
				2 * 8
				
				2 << 3
	
	*/
	/*
		计算出3的二进制：11
			00000000 00000000 00000000 00000011
		(00)000000 00000000 00000000 0000001100
			
		>>的移动：	
		计算出24的二进制：11000
			原码：10000000 00000000 00000000 00011000
			反码：11111111 11111111 11111111 11100111
			补码：11111111 11111111 11111111 11101000
			
			11111111 11111111 11111111 11101000
			1111111111 11111111 11111111 111010(00) 补码
			
			补码：1111111111 11111111 11111111 111010
			反码：1111111111 11111111 11111111 111001
			原码：1000000000 00000000 00000000 000110
			
			结果：-6
			
		>>>的移动：
			计算出24的二进制：11000
			原码：10000000 00000000 00000000 00011000
			反码：11111111 11111111 11111111 11100111
			补码：11111111 11111111 11111111 11101000
			
			11111111 11111111 11111111 11101000
			0011111111 11111111 11111111 111010(00)
			
			结果：
	*/
	@Test
	public void testOperator3() {
		// << 把<<左边的数据乘以2的移动次幂
		System.out.println(3 << 2); // 3*2^2 = 3*4 = 12;

		// >> 把>>左边的数据除以2的移动次幂
		System.out.println(24 >> 2); // 24 / 2^2 = 24 / 4 = 6
		System.out.println(24 >>> 2);

		System.out.println(-24 >> 2);
		System.out.println(-24 >>> 2);
	}
	
}
